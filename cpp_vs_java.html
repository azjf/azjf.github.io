<!DOCTYPE html>
<html lang="en">
<head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta name="generator" content="Pelican" />
        <title>C++和Java特性对比</title>
        <link rel="stylesheet" href="/theme/css/main.css" />
        <meta name="description" content="1. 变量/表达式/语句 2. 函数 3. 类 4. 模板/泛型 5. 标准库 6. 其它 7. 总结 整体而言，C++语义比Java细腻很多，表达力远胜于Java, 当然这 …" />

        <style>
          /* #content { max-width: 60em; margin: auto; } */
          .title  { text-align: center;
                     margin-bottom: .2em; }
          .subtitle { text-align: center;
                      font-size: medium;
                      font-weight: bold;
                      margin-top:0; }
          .todo   { font-family: monospace; color: red; }
          .done   { font-family: monospace; color: green; }
          .priority { font-family: monospace; color: orange; }
          .tag    { background-color: #eee; font-family: monospace;
                    padding: 2px; font-size: 80%; font-weight: normal; }
          .timestamp { color: #bebebe; }
          .timestamp-kwd { color: #5f9ea0; }
          .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
          .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
          .org-center { margin-left: auto; margin-right: auto; text-align: center; }
          .underline { text-decoration: underline; }
          #postamble p, #preamble p { font-size: 90%; margin: .2em; }
          p.verse { margin-left: 3%; }
          pre {
            border: 1px solid #e6e6e6;
            border-radius: 3px;
            background-color: #f2f2f2;
            padding: 8pt;
            font-family: monospace;
            overflow: auto;
            margin: 1.2em;
          }
          pre.src {
            position: relative;
            overflow: auto;
          }
          pre.src:before {
            display: none;
            position: absolute;
            top: -8px;
            right: 12px;
            padding: 3px;
            color: #555;
            background-color: #f2f2f299;
          }
          pre.src:hover:before { display: inline; margin-top: 14px;}
          /* Languages per Org manual */
          pre.src-asymptote:before { content: 'Asymptote'; }
          pre.src-awk:before { content: 'Awk'; }
          pre.src-authinfo::before { content: 'Authinfo'; }
          pre.src-C:before { content: 'C'; }
          /* pre.src-C++ doesn't work in CSS */
          pre.src-clojure:before { content: 'Clojure'; }
          pre.src-css:before { content: 'CSS'; }
          pre.src-D:before { content: 'D'; }
          pre.src-ditaa:before { content: 'ditaa'; }
          pre.src-dot:before { content: 'Graphviz'; }
          pre.src-calc:before { content: 'Emacs Calc'; }
          pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
          pre.src-fortran:before { content: 'Fortran'; }
          pre.src-gnuplot:before { content: 'gnuplot'; }
          pre.src-haskell:before { content: 'Haskell'; }
          pre.src-hledger:before { content: 'hledger'; }
          pre.src-java:before { content: 'Java'; }
          pre.src-js:before { content: 'Javascript'; }
          pre.src-latex:before { content: 'LaTeX'; }
          pre.src-ledger:before { content: 'Ledger'; }
          pre.src-lisp:before { content: 'Lisp'; }
          pre.src-lilypond:before { content: 'Lilypond'; }
          pre.src-lua:before { content: 'Lua'; }
          pre.src-matlab:before { content: 'MATLAB'; }
          pre.src-mscgen:before { content: 'Mscgen'; }
          pre.src-ocaml:before { content: 'Objective Caml'; }
          pre.src-octave:before { content: 'Octave'; }
          pre.src-org:before { content: 'Org mode'; }
          pre.src-oz:before { content: 'OZ'; }
          pre.src-plantuml:before { content: 'Plantuml'; }
          pre.src-processing:before { content: 'Processing.js'; }
          pre.src-python:before { content: 'Python'; }
          pre.src-R:before { content: 'R'; }
          pre.src-ruby:before { content: 'Ruby'; }
          pre.src-sass:before { content: 'Sass'; }
          pre.src-scheme:before { content: 'Scheme'; }
          pre.src-screen:before { content: 'Gnu Screen'; }
          pre.src-sed:before { content: 'Sed'; }
          pre.src-sh:before { content: 'shell'; }
          pre.src-sql:before { content: 'SQL'; }
          pre.src-sqlite:before { content: 'SQLite'; }
          /* additional languages in org.el's org-babel-load-languages alist */
          pre.src-forth:before { content: 'Forth'; }
          pre.src-io:before { content: 'IO'; }
          pre.src-J:before { content: 'J'; }
          pre.src-makefile:before { content: 'Makefile'; }
          pre.src-maxima:before { content: 'Maxima'; }
          pre.src-perl:before { content: 'Perl'; }
          pre.src-picolisp:before { content: 'Pico Lisp'; }
          pre.src-scala:before { content: 'Scala'; }
          pre.src-shell:before { content: 'Shell Script'; }
          pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
          /* additional language identifiers per "defun org-babel-execute"
               in ob-*.el */
          pre.src-cpp:before  { content: 'C++'; }
          pre.src-abc:before  { content: 'ABC'; }
          pre.src-coq:before  { content: 'Coq'; }
          pre.src-groovy:before  { content: 'Groovy'; }
          /* additional language identifiers from org-babel-shell-names in
             ob-shell.el: ob-shell is the only babel language using a lambda to put
             the execution function name together. */
          pre.src-bash:before  { content: 'bash'; }
          pre.src-csh:before  { content: 'csh'; }
          pre.src-ash:before  { content: 'ash'; }
          pre.src-dash:before  { content: 'dash'; }
          pre.src-ksh:before  { content: 'ksh'; }
          pre.src-mksh:before  { content: 'mksh'; }
          pre.src-posh:before  { content: 'posh'; }
          /* Additional Emacs modes also supported by the LaTeX listings package */
          pre.src-ada:before { content: 'Ada'; }
          pre.src-asm:before { content: 'Assembler'; }
          pre.src-caml:before { content: 'Caml'; }
          pre.src-delphi:before { content: 'Delphi'; }
          pre.src-html:before { content: 'HTML'; }
          pre.src-idl:before { content: 'IDL'; }
          pre.src-mercury:before { content: 'Mercury'; }
          pre.src-metapost:before { content: 'MetaPost'; }
          pre.src-modula-2:before { content: 'Modula-2'; }
          pre.src-pascal:before { content: 'Pascal'; }
          pre.src-ps:before { content: 'PostScript'; }
          pre.src-prolog:before { content: 'Prolog'; }
          pre.src-simula:before { content: 'Simula'; }
          pre.src-tcl:before { content: 'tcl'; }
          pre.src-tex:before { content: 'TeX'; }
          pre.src-plain-tex:before { content: 'Plain TeX'; }
          pre.src-verilog:before { content: 'Verilog'; }
          pre.src-vhdl:before { content: 'VHDL'; }
          pre.src-xml:before { content: 'XML'; }
          pre.src-nxml:before { content: 'XML'; }
          /* add a generic configuration mode; LaTeX export needs an additional
             (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
          pre.src-conf:before { content: 'Configuration File'; }

          table { border-collapse:collapse; }
          caption.t-above { caption-side: top; }
          caption.t-bottom { caption-side: bottom; }
          td, th { vertical-align:top;  }
          th.org-right  { text-align: center;  }
          th.org-left   { text-align: center;   }
          th.org-center { text-align: center; }
          td.org-right  { text-align: right;  }
          td.org-left   { text-align: left;   }
          td.org-center { text-align: center; }
          dt { font-weight: bold; }
          .footpara { display: inline; }
          .footdef  { margin-bottom: 1em; }
          .figure { padding: 1em; }
          .figure p { text-align: center; }
          .equation-container {
            display: table;
            text-align: center;
            width: 100%;
          }
          .equation {
            vertical-align: middle;
          }
          .equation-label {
            display: table-cell;
            text-align: right;
            vertical-align: middle;
          }
          .inlinetask {
            padding: 10px;
            border: 2px solid gray;
            margin: 10px;
            background: #ffffcc;
          }
          #org-div-home-and-up
           { text-align: right; font-size: 70%; white-space: nowrap; }
          textarea { overflow-x: auto; }
          .linenr { font-size: smaller }
          .code-highlighted { background-color: #ffff00; }
          .org-info-js_info-navigation { border-style: none; }
          #org-info-js_console-label
            { font-size: 10px; font-weight: bold; white-space: nowrap; }
          .org-info-js_search-highlight
            { background-color: #ffff00; color: #000000; font-weight: bold; }
          .org-svg { }
        </style>

        <script>
          window.MathJax = {
            tex: {
              ams: {
                multlineWidth: '85%'
              },
              tags: 'ams',
              tagSide: 'right',
              tagIndent: '.8em'
            },
            chtml: {
              scale: 1.0,
              displayAlign: 'center',
              displayIndent: '0em'
            },
            svg: {
              scale: 1.0,
              displayAlign: 'center',
              displayIndent: '0em'
            },
            output: {
              font: 'mathjax-modern',
              displayOverflow: 'overflow'
            }
          };
        </script>

        <script
          id="MathJax-script"
          async
          src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
        </script>
</head>

<body id="index" class="home">
        <header id="banner" class="body">
                <nav><ul>
                    <li><a href="/">首页</a></li>
                    <li><a href="/categories.html">分类</a></li>
                    <li><a href="/tags.html">标签</a></li>
                    <li><a href="/archives.html">归档</a></li>
                    <li><a href="https://github.com/azjf">关于</a></li>
                </ul></nav>
        </header><!-- /#banner -->
<section id="content" class="body">
  <article>
    <header>
      <h1 class="entry-title">
        <a href="/cpp_vs_java.html" rel="bookmark"
           title="Permalink to C++和Java特性对比">C++和Java特性对比</a></h1>
    </header>

    <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2024-03-03T00:00:00+08:00">
                2024-03-03
        </abbr>
<p>分类: <a href="/category/c.html">C++</a></p>
标签: <a href="/tag/c.html">C++</a> <a href="/tag/java.html">Java</a> 
</footer><!-- /.post-info -->      <div id="table-of-contents" role="doc-toc">

<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org2c8c59c">1. 变量/表达式/语句</a></li>
<li><a href="#orgd14de0e">2. 函数</a></li>
<li><a href="#org5e83a9a">3. 类</a></li>
<li><a href="#orgf82e393">4. 模板/泛型</a></li>
<li><a href="#orgca33189">5. 标准库</a></li>
<li><a href="#orgcbb2122">6. 其它</a></li>
<li><a href="#orgb91bceb">7. 总结</a></li>
</ul>
</div>
</div>
<p>
整体而言，C++语义比Java细腻很多，表达力远胜于Java, 当然这也导致开发时更大的心理包袱。
接下来，本文将从多个层级上讨论C++和Java语言特性的主要区别，希望能对大家有所帮助。
</p>
<div id="outline-container-org2c8c59c" class="outline-2">
<h2 id="org2c8c59c"><span class="section-number-2">1.</span> 变量/表达式/语句</h2>
<div class="outline-text-2" id="text-1">
<ol class="org-ol">
<li>C++ int/char/float/double等基础类型是变长的，这是为了能够更好地发挥具有不同字长的各体系架构的性能。
而Java因可移植性而选择运行在JVM中，因此这些基础类型都是固定长度。</li>
<li>C++可以通过const描述变量自身或所指对象是否可以被修改，而Java只能通过final描述变量所指引用不能被修改。</li>
<li>异常
<ol class="org-ol">
<li>C++可以抛出任何变量作为异常，而Java仅能抛出Throwable. 为了捕获所有类型的可捕获异常，C++需要使用​<code>catch(...)</code>​, 而Java仅需​<code>catch(Throwable)</code>​.</li>
<li>C++仅有try-catch, 而Java还有finally语句，其被用于解决析构函数调用时机不明确的问题</li>
</ol></li>
</ol>
</div>
</div>
<div id="outline-container-orgd14de0e" class="outline-2">
<h2 id="orgd14de0e"><span class="section-number-2">2.</span> 函数</h2>
<div class="outline-text-2" id="text-2">
<ol class="org-ol">
<li>C++函数虽然不是一等公民，但其可以被以指针形式存入变量，而Java仅能将其通过lambda包装为匿名类对象后再存于变量中，因此多少有些笨重。</li>
<li>C++函数可以​<b>修改入参本身</b>​（通过传引用或指针），而Java只能修改入参所指对象。
此外，Java包装类型和String等都是不可变的，因此为了达到C++修改函数入参的类似的效果，Java必须将基础类型包装为类。
因此，当函数需要返回多个值时（很多C函数返回值都只是错误码，而具体返回内容则通过入参返回），Java需要自定义类来包装它们，而这相对比较笨拙。</li>
<li>C++函数允许后置出参类型，而这使得其出参类型可以根据入参来推导，而Java则不行。</li>
<li>C++函数里定义static变量，其具有局部作用域和全局生命周期，而Java方法则不可以。</li>
<li>C++和Java lambda都是基于匿名类实现的，但是C++可以更精确地控制对外部变量的捕获。</li>
<li>C++函数可以独立存在，而Java方法必须依附于某个类。</li>
<li>C++函数允许入参有默认参数，虽然其只是编译时的语法糖，其有时候也能简化代码撰写，而Java函数则无此功能。</li>
</ol>
</div>
</div>
<div id="outline-container-org5e83a9a" class="outline-2">
<h2 id="org5e83a9a"><span class="section-number-2">3.</span> 类</h2>
<div class="outline-text-2" id="text-3">
<ol class="org-ol">
<li>对象构造与销毁
<ol class="org-ol">
<li>C++可以控制对象创建与销毁等各个阶段的行为，包括构造/析构/拷贝/移动/赋值。
另外，其析构函数调用时机明确，因此其特性还被用来实现RAII以管理资源.
最后，C++还可以通过placement new控制对象构造内存地点，这个特性这使得C++容器可以将所有元素内存聚集在一起。</li>
<li>Java仅能控制构造和析构阶段行为，且析构时机不明确（垃圾回收时）。
为了实现资源管理，Java提供了try with resource和finally子句。</li>
</ol></li>
<li>运行时反射
<ol class="org-ol">
<li>运行时反射可以在运行时获取对象元数据（类信息），而这是如Spring等Java框架能够存在的根本前提。</li>
<li>Java反射的实现原理为对象头部具有对象元数据，其可以在运行时被提取出来。</li>
<li>C++的设计原则之一为You don't pay for what you don't use, 因此不含虚函数的类对象的内存布局基本上等同于C struct, 进而不包含类信息，因此无法完成运行时反射。
不过，C++模板十分强大，可以通过其SFINE等模板黑魔法实现编译时反射。</li>
</ol></li>
<li>多继承
<ol class="org-ol">
<li>C++允许多继承，进而导致必须严格安排<a href="https://azjf.github.io/cpp_vtable.html">对象内存布局</a>以确保对象内存中包含子类的对应的子对象。
此外，为了解决菱形继承问题，C++还引入了虚继承，而这使得对象内存布局更加复杂。</li>
<li>Java不允许多继承，因此没有这些烦恼。</li>
</ol></li>
<li>运算符重载。C++的另外一个设计原则为让自定义类型和内置类型一样好用，因此允许运算符重载，而Java则没这个能力。</li>
<li>C++对象内存中保存的是属性本身，因此可以将对象所依赖的数据聚集在一起而具有很好的空间邻近性。
Java对象内存中保存的是属性引用，属性实际内存则散落于堆上。</li>
<li>C++默认所有方法为非virtual方法，而Java则仅默认private方法为非virtual。
另外，Java可以通过final来表明虚函数不可被覆盖，C++则不行。</li>
</ol>
</div>
</div>
<div id="outline-container-orgf82e393" class="outline-2">
<h2 id="orgf82e393"><span class="section-number-2">4.</span> 模板/泛型</h2>
<div class="outline-text-2" id="text-4">
<ol class="org-ol">
<li>C++模板的作用时机为编译时，其是自身是图灵完备的，进化出了模板元编程之类的黑魔法。
Java泛型仅有编译时参数类型检测的效果，能力相对较弱。</li>
<li>C++函数模板具有参数完美转发能力，可以据此更好地实现高阶函数。
Java无类似功能，其方法甚至不能脱离类而独立存在。</li>
</ol>
</div>
</div>
<div id="outline-container-orgca33189" class="outline-2">
<h2 id="orgca33189"><span class="section-number-2">5.</span> 标准库</h2>
<div class="outline-text-2" id="text-5">
<ol class="org-ol">
<li>STL容器接口比Java集合接口命名更规范，比如STL容器元素数量都可以用size()来获取，而Java有size()函数、length属性和length()方法等。
STL容器接口命名规范也是其可以将泛型算法独立于容器的根本原因。</li>
<li>STL容器可以通过placement new将元素对象内存聚焦在一起，而Java集合里存的都是引用，实际对象内存散落在堆上，因此空间邻近性不太好。</li>
<li>C++ 11之前不承认多线程，目前多线程标准库功能丰富性也远不如Java JUC, 不过以后情况应该会有所改善。</li>
</ol>
</div>
</div>
<div id="outline-container-orgcbb2122" class="outline-2">
<h2 id="orgcbb2122"><span class="section-number-2">6.</span> 其它</h2>
<div class="outline-text-2" id="text-6">
<ol class="org-ol">
<li>C++有很多undefined behavior, 因为其为了性能最大化而基本上不检查边界条件（其认为边界条件检查是用户责任，因为并非所有应用都需要检查每一个边界条件）。
Java基本上没类似概念。</li>
<li>C++标准委员会仅制定标准，而编译器厂商的实现可能并不完全符合标准（比如MSVC早期对C++标准的支持就不太好）。
Oracle则对Java有很强的控制力，因此较少出现这种情况。</li>
</ol>
</div>
</div>
<div id="outline-container-orgb91bceb" class="outline-2">
<h2 id="orgb91bceb"><span class="section-number-2">7.</span> 总结</h2>
<div class="outline-text-2" id="text-7">
<p>
本文从多个层级上讨论了C++和Java主要区别，暂时先写这些，以后想到时再补充。
</p>
</div>
</div>

    </div><!-- /.entry-content -->

  </article>
</section>
        <section id="extras" class="body">
        </section><!-- /#extras -->

</body>
</html>